---
title: "PS1"
format: pdf
---

## Problem 1: Abalone Data

a.  Import the data into a data.frame in R. Use the information in the “abalone.names” file to give appropriate column names. (Note: Downloading and unzipping the file can take place outside of your submitted document, but importing the file should be in the submission.)

```{r}
abalone_data <- read.csv("data/abalone/abalone.data", header = FALSE)

# set appropriate colnames according to abalone.names
colnames(abalone_data) <- c("Sex", "Length", "Diam", "Height", "Whole", "Shucked", "Viscera", "Shell", "Rings")

abalone_data
summary(abalone_data)

# rm(list=ls())
```

b.  The data contains information on three different sexes of abalone. Report the number of observations belonging to each sex.

```{r}
table(abalone_data$Sex)
```

c.  Use the data to answer the following questions:

1.  Which weight has the highest correlation with rings?
2.  For that weight, which sex has the highest correlation?
3.  What are the weights of the abalone with the most rings?
4.  What percentage of abalones have a viscera weight larger than their shell weight?

```{r}
# Q1
cor(abalone_data$Rings, abalone_data[5:8])

### split up code chunks 
### put below in text
### look up single tick r, inline code 
paste0("Shell weight has the highest correlation with rings with a correlation coefficient of ", cor(abalone_data$Shell, abalone_data$Rings))

# Q2
sexes <- unique(abalone_data$Sex)
sapply(sexes, function(sex) {
  abalone_by_sex <- abalone_data[abalone_data$Sex == sex, ]
  cor(abalone_by_sex[["Shell"]], abalone_by_sex$Rings)
})

paste0("Infants have the highest correlation between shell weight and rings with a value of ")

# Q3
most_rings_idx <- which.max(abalone_data$Rings)
abalone_data[most_rings_idx, 5:8]

# Q4
mean(abalone_data$Viscera > abalone_data$Shell)
```

d.  Create a table of correlations between weights and rings, within each sex. The columns should be the four weights, and the rows should be the sexes. (This table does not need to be “fancy” but should clearly identify what each value represents.)

``` {r}
weights <- c("Whole", "Shucked", "Viscera", "Shell")

sapply(weights, function(w) {
  sapply(sexes, function(sex) {
    abalone_by_sex <- abalone_data[abalone_data$Sex == sex, ]
    cor(abalone_by_sex[[w]], abalone_by_sex$Rings)
  })
})
```

e. Carry out a series of t-tests to examine whether the number of rings differs across the three sexes. Present the R output and interpret the results.

``` {r}

manual_t_test <- function(sex1, sex2) {
  rings1 <- abalone_data$Rings[abalone_data$Sex == sex1]
  rings2 <- abalone_data$Rings[abalone_data$Sex == sex2]
  
  var1 <- var(rings1)
  var2 <- var(rings2)
  
  n1 <- length(rings1)
  n2 <- length(rings2)
  
  t_stat <- abs((mean(rings1) - mean(rings2)) / (sqrt((var1/n1) + (var2/n2))))
  df <- ((var1/n1)+(var2/n2))^2 / ( (((var1/n1)^2)/(n1-1)) + (((var2/n2)^2)/(n2-1)))
  
  p_val <- 2 * pt(-t_stat, df)
  paste0("Welch's t-test between ", sex1, " and ", sex2," -> p-value: ", signif(p_val, 4), ", t-stat: ", signif(t_stat, 4), ", df: " , signif(df, 4))
}

manual_t_test("M", "F")
manual_t_test("I", "F")
manual_t_test("M", "I")

t.test(Rings ~ Sex, data = abalone_data, subset = Sex %in% c("M", "F"))
```

## Q2

```{r}
food_data <- read.csv("data/food_expenditure.csv")
```

``` {r}
# Clean up the variable names
colnames(food_data)

# ID is fine
colnames(food_data) <- c("ID", "Age", "Household", "State", "Currency", 
                         "Expenditure_Total", "Expenditure_Grocery", "Expenditure_Dining", "Expenditure_Misc",
                         "Num_Dining", "Alcohol", "Assistance")
food_data
```

``` {r}
nrow(food_data)
food_usd <- food_data[food_data$Currency == "USD", ]
food_usd
nrow(food_usd)
```

``` {r}
summary(food_usd$Age)

sort(table(food_usd$State))

expenditures <- c("Expenditure_Total", "Expenditure_Grocery", "Expenditure_Dining", "Expenditure_Misc")
summary(food_usd[expenditures])

summary(food_usd$Num_Dining)
```

## Q3

```{r}
# remember to give errors
nextCollatz <- function(n) {
  # x must be a positive integer
  
  # if n is even
  if (n %% 2 == 0) {
    return(n/2)
  } else {
    return(3*n+1)
  }
}

nextCollatz(5)
nextCollatz(16)
```

``` {r}
collatzSequence <- function(n) {
  seq <- n
  
  while (n != 1) {
    n <- nextCollatz(n)
    seq <- c(seq, n)
  }
  
  return(list(seq, length(seq)))
}

collatzSequence(5)
collatzSequence(19)
```

``` {r}
values <- 100:500

collatz_lengths <- sapply(values, function(value) {
  collatzSequence(value)[[2]]
})


shortest_length <- min(collatz_lengths)
shortest_ind <- which.min(collatz_lengths)
longest_length <- max(collatz_lengths)
longest_ind <- which.max(collatz_lengths)

c(shortest_length, longest_length)
c(values[shortest_ind], values[longest_ind])
```
